/*
 * aging.cpp
 *
 *  Created on: 5 Jun 2018
 *      Author: Dean De Leo
 */

#include "aging.hpp"

#include <cstdio> // tmpname
#include <errno.h>
#include <fstream>
#include <libgen.h> // dirname
#include <sys/stat.h>
#include <sys/wait.h> // waitpid
#include <unistd.h> // readlink
#include <sstream>

#include "configuration.hpp"
#include "database.hpp"
#include "miscellaneous.hpp"
#include "profiler.hpp"
#include "timer.hpp"

#define RAISE(message) RAISE_EXCEPTION(pma::ExperimentError, message)
// Report the given message `preamble' together with the associated `time' in milliseconds
#define REPORT_TIME( preamble, time ) { std::cout << preamble << ' '; \
    if( time > 3000 ) { std::cout << (static_cast<double>(time) / 1000) << " seconds" << std::endl; } \
    else { std::cout << time << " milliseconds" << std::endl; } }

using namespace abtree;
using namespace std;

namespace pma {


ExperimentAging::ExperimentAging(shared_ptr<Interface> abtree_instance, size_t initial_size, size_t total_operations, size_t batch_size,
        size_t scan_warmup, size_t scan_num_trials,
        const std::string& temporary_folder, uint64_t seed):
    m_instance(dynamic_pointer_cast<ABTree>(abtree_instance)), m_initial_size(initial_size),
    m_total_operations(total_operations), m_batch_size(batch_size), m_scan_warmup(scan_warmup), m_scan_trials(scan_num_trials),
    m_temporary_folder(temporary_folder), m_distribution_seed(seed)
 {
    if(m_instance.get() == nullptr) RAISE("Invalid instance: it's not an ABTree!");
    if(m_instance->size() != 0) { RAISE("The given instance is not empty"); }
    if(m_initial_size <= 0) RAISE("Invalid value for the argument initial size, expected to be > 0: " << m_initial_size);
    if(m_total_operations <= 0) RAISE("Invalid value for the argument `total_operations', expected to be > 0: " << m_total_operations);
    if(m_batch_size <= 0) RAISE("Invalid value for the argument `batch_size', expeceted to be > 0: " << m_batch_size);
    if(m_scan_trials <= 0) RAISE("Invalid value for the argument `num_scan_trials'. Expected to be >0: " << m_scan_trials);
}

ExperimentAging::~ExperimentAging(){
    // Remove the files generated by the utility. Ignore the return codes.
    if(!m_path_initial_load.empty()){
        unlink(m_path_initial_load.c_str());
        m_path_initial_load = "";
    }
    if(!m_path_insert_keys.empty()){
            unlink(m_path_insert_keys.c_str());
            m_path_insert_keys = "";
    }
    if(!m_path_delete_keys.empty()){
            unlink(m_path_delete_keys.c_str());
            m_path_delete_keys = "";
    }
}

void ExperimentAging::preprocess () {
    // Generate the keys for the experiment
    generate_keys();

    // pin the current thread
    pin_thread_to_cpu();
    m_thread_pinned = true;
}

string ExperimentAging::get_path_generator(){
    // Path to the current program
    constexpr size_t buffer_sz = 2048;
    char path[buffer_sz];
    auto rc = readlink("/proc/self/exe", path, buffer_sz -1);
    if(rc <= 0) RAISE("Cannot resolve the path to the current program");
    path[rc] = '\0'; // null terminator
    // Retrieve the top directory
    dirname(path);
    // Final path
    string path_utility{path};
    path_utility += "/aging_generate";

    // Check the program exists
    struct stat stat_output;
    int rc_stat = stat(path_utility.c_str(), &stat_output);
    if(rc_stat != 0){
        RAISE("The program `" << path_utility << "' does not exist or file system error: " << errno);
    }

    return path_utility;
}

template<typename T>
static string to_string(T value){
    std::stringstream ss;
    ss << value;
    return ss.str();
}

void ExperimentAging::generate_keys(){
    LOG_VERBOSE("Generating the keys for the experiment...");
    // Invoke the utility `aging_generate'
    cout << "[ExperimentAging::generate_keys]" << endl;
    auto path_generator = get_path_generator();
    cout << "Path generator: " << path_generator << endl;

    string str_files = m_temporary_folder + "/pmacomp_" + random_string(8) + "_";
    m_path_initial_load = str_files + "init.bin";
    m_path_insert_keys = str_files + "insert.bin";
    m_path_delete_keys = str_files + "delete.bin";

    pid_t child_process = fork();
    if(child_process == 0){ // child
        auto str_initial_size = to_string(m_initial_size);
        auto str_total_operations = to_string(m_total_operations);
        auto str_batch_size = to_string(m_batch_size);
        auto str_seed = to_string(m_distribution_seed);

        execl(path_generator.c_str(), path_generator.c_str(),
                "--file_initial", m_path_initial_load.c_str(),
                "--file_insert", m_path_insert_keys.c_str(),
                "--file_delete", m_path_delete_keys.c_str(),
                "--initial_size", str_initial_size.c_str(),
                "-I", str_total_operations.c_str(),
                "--idls_group_size", str_batch_size.c_str(),
                "--seed_random_permutation", str_seed.c_str(),
                (char*) NULL);
        exit(EXIT_FAILURE);
    } else { // parent
        int status = 0;
        waitpid(child_process, &status, 0);
        if(!WIFEXITED(status) && WEXITSTATUS(status) == 0){
            RAISE("Execution aborted: " << path_generator);
        }
    }

    LOG_VERBOSE("Keys generated");
}

void ExperimentAging::fill(std::fstream& input, int64_t* output, size_t output_sz){
    if(!input.good()) RAISE("Input file in bad state");
    for(size_t i = 0; i < output_sz; i++){
        union{
            int64_t key;
            char buffer[8];
        } item;

        input.read(item.buffer, sizeof(item));
        output[i] = item.key;
    }
}

//   virtual void load(const std::pair<int64_t, int64_t>* elements, size_t elements_sz);
size_t ExperimentAging::run_load(){
    unique_ptr<pair<int64_t, int64_t>[]> elements_ptr { new pair<int64_t, int64_t>[ m_initial_size] };
    auto elements = elements_ptr.get();

    // read the keys from the input file
    fstream input(m_path_initial_load, ios::in);
    if(!input.good()) RAISE("The file `" + m_path_initial_load + "' does not exist");
    for(size_t i = 0; i < m_initial_size; i++){
        union{
            int64_t key;
            char buffer[8];
        } item;

        input.read(item.buffer, sizeof(item));
        elements[i].first = elements[i].second = item.key;
    }
    input.close();

    Timer timer {true};
    m_instance->load(elements, m_initial_size);
    timer.stop();

    REPORT_TIME("Loaded " << m_initial_size << " elements. Elapsed time:", timer.milliseconds());

    return timer.microseconds();
}

void ExperimentAging::run_warmup(){
    if(m_scan_warmup > 0){
        LOG_VERBOSE("Warm up: executing " << m_scan_warmup << " scans over the data structure");
        run_scans(m_scan_warmup);
        LOG_VERBOSE("Warm up: completed");
    }
}


void ExperimentAging::run_inserts(int64_t* __restrict input_keys, size_t count){
    Interface* __restrict instance = m_instance.get();

    for(size_t i = 0; i < count; i++){
        auto key = input_keys[i];
        instance->insert(key, key);
    }
}

void ExperimentAging::run_deletions(int64_t* __restrict input_keys, size_t count){
    Interface* __restrict instance = m_instance.get();
    for(size_t i = 0; i < count; i++){
        auto key = input_keys[i];

#if !defined(NDEBUG)
        auto value = instance->remove(key);
        assert(value == key && "Key/value mismatch");
#else
        instance->remove(key);
#endif
    }
}

static volatile uint64_t sum_disable_opt_keys, sum_disable_opt_values;

void ExperimentAging::run_scans(size_t count){
    Interface* __restrict instance = m_instance.get();

    for(size_t i = 0; i < count; i++){
        auto sum = instance->sum(numeric_limits<int64_t>::min(), numeric_limits<int64_t>::max());

        sum_disable_opt_keys = sum.m_sum_keys;
        sum_disable_opt_values = sum.m_sum_values;
    }
}

void ExperimentAging::run(){
    // Perform the initial inserts
    run_load();

    // If requested, perform `m_scan_warmup' iterations on the built data structure to warm up the processor
    run_warmup();

    unique_ptr<int64_t[]> keys_insert_ptr{ new int64_t[m_batch_size] };
    auto keys_insert = keys_insert_ptr.get();
    unique_ptr<int64_t[]> keys_delete_ptr{ new int64_t[m_batch_size] };
    auto keys_delete = keys_delete_ptr.get();
    fstream input_insert(m_path_insert_keys, ios::in);
    fstream input_delete(m_path_delete_keys, ios::in);

    // Sequence of insert/deletes/scans
//    auto insdel_ptr = m_keys_experiment.insdel_step();
//    auto insdel_distr = insdel_ptr.get();
    size_t count_total_operations = 0;
    size_t round = 0;
    while(count_total_operations < m_total_operations){
        Timer t_insert;
        Timer t_delete;
        Timer t_scan;

        // get the avg memory distance among the leaves
        auto stats = m_instance->get_stats_leaf_distance();

        // perform `m_scan_trials' scans
        ONLY_IF_PROFILING_ENABLED( BranchMispredictionsProfiler profiler; profiler.start() );
        t_scan.start();
        run_scans(m_scan_trials);
        t_scan.stop();
        ONLY_IF_PROFILING_ENABLED( auto profiler_snapshot = profiler.stop() );

        // Read the keys to insert
        fill(input_insert, keys_insert, m_batch_size);
        // Perform `m_batch_size' inserts
        t_insert.start();
        run_inserts(keys_insert, m_batch_size);
        t_insert.stop();

        // Read the keys to insert
        fill(input_delete, keys_delete, m_batch_size);
        // Perform `m_batch_size' deletions
        t_delete.start();
        run_deletions(keys_delete, m_batch_size);
        t_delete.stop();

        assert(m_instance->size() == m_initial_size && "The data structure should return to its initial size after an equal number of insertions and deletions");
        if(m_instance->size() != m_initial_size) RAISE("The data structure should return to its initial size after an equal number of insertions and deletions");

        cout << "[Round " << round << "] insertion time: " << t_insert.milliseconds() << " millisecs, deletion time: " <<
                t_delete.milliseconds() << " millisecs, scan time [#" << m_scan_trials << "]: " << t_scan.milliseconds() << " milliseconds, "
                        "leaf distance: " << stats.m_distance_avg << " bytes" << std::endl;

        config().db()->add("aging")
                        ("round", round)
                        ("t_inserts_millisecs", t_insert.milliseconds<uint64_t>())
                        ("t_deletes_millisecs", t_delete.milliseconds<uint64_t>())
                        ("t_scans_millisecs",  t_scan.milliseconds<uint64_t>())
                        ("num_leaves", stats.m_num_leaves)
                        ("leaf_memdist_avg", stats.m_distance_avg)
                        ("leaf_memdist_stddev", stats.m_distance_stddev)
                        ("leaf_cardinality_avg", stats.m_cardinality_avg)
                        ("leaf_cardinality_stddev", stats.m_cardinality_stddev)
                        ;

        ONLY_IF_PROFILING_ENABLED(
            config().db()->add("profiler_aging_brmsp")
                ("round", round)
                ("t_inserts_millisecs", t_insert.milliseconds<uint64_t>())
                ("t_deletes_millisecs", t_delete.milliseconds<uint64_t>())
                ("t_scans_millisecs",  t_scan.milliseconds<uint64_t>())
                ("num_leaves", stats.m_num_leaves)
                ("leaf_memdist_avg", stats.m_distance_avg)
                ("leaf_memdist_stddev", stats.m_distance_stddev)
                ("leaf_cardinality_avg", stats.m_cardinality_avg)
                ("leaf_cardinality_stddev", stats.m_cardinality_stddev)
                ("scan_conditional_branches", profiler_snapshot.m_conditional_branches)
                ("scan_branch_mispredictions", profiler_snapshot.m_branch_mispredictions)
                ("scan_l1_misses", profiler_snapshot.m_cache_l1_misses)
                ("scan_llc_misses", profiler_snapshot.m_cache_llc_misses);
        );

        count_total_operations += 2* m_batch_size;
        round++;
    }

    input_insert.close();
    input_delete.close();
}

void ExperimentAging::postprocess(){
    if(m_thread_pinned){
        unpin_thread();
    }
}





} // namespace pma


